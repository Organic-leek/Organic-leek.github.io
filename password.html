<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试."
     data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
    <script id="hbeData" type="hbeData" data-hmacdigest="ab966da4e4bb4fa1bc07766c49813fe5f2ae9c2db9499157f2757c6683d106ba">681c8094126851f24d995d958a1ceeaa5c01fdae1b683e46504f5a42545962261cc26c1c4bdc1d63c2543c58ddaa5f6c5b5d60a5aa29086cb38b8ff992ce08cec319efc9da7ef23b757a1ee8350ca0d7861b40c16dfbbaef3aeb57d38aadb5b216bee8564f0041a11969510d82d03aaaed15691a360230c7875ebf8d62f85e8cbb2cdaebe110217e7991cdc47a010d787bb5f201fdf9d5f7997c337a5be791fc207fd8146f23fc6a03d37578fb523ab6041391484e3812ba2eba6a76e8c01ec39c0fe9496a2ebe2b4c764ae6d786b3ad4333b866de2f98eb735b69cb8b8341cb383ac155c3bba59cc7222587edf661d1579f1f0d00d8735d908f1cf4ee46f17eeef2a5eec15ff4e4839a53c747dd9815cefca88fe5cc4e02147f3784ac84dd04a2d91cc3219e4c1adf1a44249e8477c9af8e952b2a302f3b5c1b1bdd05e86c2bac21461901a54244a019d473bfb722e3f227f55b8781b9e149ac81208559d6550eb1e2a54180d5b3767a195d4e4515af66127bd6c8fdc3887f262addb5d702a088907c449ab8001a5cece22f2f3d56c2c6c128c9cca2160f2d39e06012fd1fc1583439c3191d393aec69c2f4ecb76202f6e4527ee33e1a422ff8325e8e8951f9d21bbdad79115b4a0f930b0bd34b65b61fba5aaae6192b29446031c552eecc379c15760c9dd3e7c21ac5e33b0048de3b</script>
    <div class="hbe hbe-content">
        <div class="hbe hbe-input hbe-input-xray">
            <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
            <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
                <span
                id="pjc" class="hbe hbe-input-label-content hbe-input-label-content-xray">False
                </span>
            </label>
            <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60"
                 preserveAspectRatio="none">
                <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
                <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
            </svg>
        </div>
    </div>
</div>
<script>
(() => {
  'use strict';

  const cryptoObj = window.crypto || window.msCrypto;
  const storage = window.localStorage;

  const storageName = 'hexo-blog-encrypt:#' + window.location.pathname;
  const keySalt = textToArray('hexo-blog-encrypt的作者们都是大帅比!');
  const ivSalt = textToArray('hexo-blog-encrypt是地表最强Hexo加密插件!');

// As we can't detect the wrong password with AES-CBC,
// so adding an empty div and check it when decrption.
const knownPrefix = "<hbe-prefix></hbe-prefix>";

  const mainElement = document.getElementById('hexo-blog-encrypt');
  const wrongPassMessage = mainElement.dataset['wpm'];
  const wrongHashMessage = mainElement.dataset['whm'];
  const dataElement = mainElement.getElementsByTagName('script')['hbeData'];
  const encryptedData = dataElement.innerText;
  const HmacDigist = dataElement.dataset['hmacdigest'];

  function hexToArray(s) {
    return new Uint8Array(s.match(/[\da-f]{2}/gi).map((h => {
      return parseInt(h, 16);
    })));
  }

  function textToArray(s) {
    var i = s.length;
    var n = 0;
    var ba = new Array()

    for (var j = 0; j < i;) {
      var c = s.codePointAt(j);
      if (c < 128) {
        ba[n++] = c;
        j++;
      } else if ((c > 127) && (c < 2048)) {
        ba[n++] = (c >> 6) | 192;
        ba[n++] = (c & 63) | 128;
        j++;
      } else if ((c > 2047) && (c < 65536)) {
        ba[n++] = (c >> 12) | 224;
        ba[n++] = ((c >> 6) & 63) | 128;
        ba[n++] = (c & 63) | 128;
        j++;
      } else {
        ba[n++] = (c >> 18) | 240;
        ba[n++] = ((c >> 12) & 63) | 128;
        ba[n++] = ((c >> 6) & 63) | 128;
        ba[n++] = (c & 63) | 128;
        j += 2;
      }
    }
    return new Uint8Array(ba);
  }

  function arrayBufferToHex(arrayBuffer) {
    if (typeof arrayBuffer !== 'object' || arrayBuffer === null || typeof arrayBuffer.byteLength !== 'number') {
      throw new TypeError('Expected input to be an ArrayBuffer')
    }

    var view = new Uint8Array(arrayBuffer)
    var result = ''
    var value

    for (var i = 0; i < view.length; i++) {
      value = view[i].toString(16)
      result += (value.length === 1 ? '0' + value : value)
    }

    return result
  }

  async function getExecutableScript(oldElem) {
    let out = document.createElement('script');
    const attList = ['type', 'text', 'src', 'crossorigin', 'defer', 'referrerpolicy'];
    attList.forEach((att) => {
      if (oldElem[att])
        out[att] = oldElem[att];
    })

    return out;
  }

  async function convertHTMLToElement(content) {
    let out = document.createElement('div');
    out.innerHTML = content;
    out.querySelectorAll('script').forEach(async (elem) => {
      elem.replaceWith(await getExecutableScript(elem));
    });

    return out;
  }

  function getKeyMaterial(password) {
    let encoder = new TextEncoder();
    return cryptoObj.subtle.importKey(
      'raw',
      encoder.encode(password),
      {
        'name': 'PBKDF2',
      },
      false,
      [
        'deriveKey',
        'deriveBits',
      ]
    );
  }

  function getHmacKey(keyMaterial) {
    return cryptoObj.subtle.deriveKey({
      'name': 'PBKDF2',
      'hash': 'SHA-256',
      'salt': keySalt.buffer,
      'iterations': 1024
    }, keyMaterial, {
      'name': 'HMAC',
      'hash': 'SHA-256',
      'length': 256,
    }, true, [
      'verify',
    ]);
  }

  function getDecryptKey(keyMaterial) {
    return cryptoObj.subtle.deriveKey({
      'name': 'PBKDF2',
      'hash': 'SHA-256',
      'salt': keySalt.buffer,
      'iterations': 1024,
    }, keyMaterial, {
      'name': 'AES-CBC',
      'length': 256,
    }, true, [
      'decrypt',
    ]);
  }

  function getIv(keyMaterial) {
    return cryptoObj.subtle.deriveBits({
      'name': 'PBKDF2',
      'hash': 'SHA-256',
      'salt': ivSalt.buffer,
      'iterations': 512,
    }, keyMaterial, 16 * 8);
  }

 async function decrypt(decryptKey, iv, hmacKey) {
    let typedArray = hexToArray(encryptedData);

    const result = await cryptoObj.subtle.decrypt({
      'name': 'AES-CBC',
      'iv': iv,
    }, decryptKey, typedArray.buffer).then(async (result) => {
      const decoder = new TextDecoder();
      const decoded = decoder.decode(result);

      // check the prefix, if not then we can sure here is wrong password.
      if (!decoded.startsWith(knownPrefix)) {
        return false;
      }else{
        return true;
      }
    }).catch((e) => {
      return false;
    });

    return result;

  }

  function hbeLoader() {


    mainElement.addEventListener('keydown', async (event) => {
      if (event.isComposing || event.keyCode === 13) {
        const password = document.getElementById('hbePass').value;
        const keyMaterial = await getKeyMaterial(password);
        const hmacKey = await getHmacKey(keyMaterial);
        const decryptKey = await getDecryptKey(keyMaterial);
        const iv = await getIv(keyMaterial);

        decrypt(decryptKey, iv, hmacKey).then((result) => {
          if (result) {
            document.getElementById('pjc').innerHTML=password
          }
        });
      }
    });
  }

  hbeLoader();


})();

</script>

</body>
</html>